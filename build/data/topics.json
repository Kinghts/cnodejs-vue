{
  "success": true,
  "data": [
    {
      "id": "58e607b0ddee72813eb22323",
      "author_id": "4efc278525fa69ac6900000f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/cnpm/cnpm\">cnpm cli</a> 的 install 速度已经是目前最快的一种 npm installer 了，最近 npm registry 推出了一种全新的 registry api 格式: <a href=\"https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#abbreviated-metadata-format\">Abbreviated metadata format</a>，它可以大大减少install 过程中的网络请求数据大小，于是我们也在第一时间实现到 npminstall 中了。</p>\n<p>为了更加平滑地更新过渡，我们计划使用2周时间来做beta测试，然后没什么大问题之后，将会发布正式版本的 cnpm<a href=\"/user/5\">@5</a> 。</p>\n<h2>尝鲜者来</h2>\n<p>直接通过 beta 版本可以参与测试。</p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm@beta -g \n</code></pre><h2>问题反馈</h2>\n<p>遇到任何问题，请直接回复到 <a href=\"https://github.com/cnpm/cnpm/pull/187\">https://github.com/cnpm/cnpm/pull/187</a> 。</p>\n<h2>回滚</h2>\n<p>一键回滚到稳定版本。</p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm -g\n</code></pre></div>",
      "title": "cnpm@5 beta 测试招募",
      "last_reply_at": "2017-05-10T02:37:05.917Z",
      "good": false,
      "top": true,
      "reply_count": 75,
      "visit_count": 14652,
      "create_at": "2017-04-06T09:17:36.511Z",
      "author": {
        "loginname": "fengmk2",
        "avatar_url": "https://avatars3.githubusercontent.com/u/156269?v=3&s=120"
      }
    },
    {
      "id": "58eee565a92d341e48cfe7fc",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日��采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是实用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更��速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>",
      "title": "2017，我们来聊聊 Node.js",
      "last_reply_at": "2017-05-09T02:27:29.030Z",
      "good": true,
      "top": true,
      "reply_count": 54,
      "visit_count": 12702,
      "create_at": "2017-04-13T02:41:41.818Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
      }
    },
    {
      "id": "58d0fb3517f61387400b7e15",
      "author_id": "4f447c2f0a8abae26e01b27d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png\" alt=\"screenshot.png\"></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/25860846\">https://zhuanlan.zhihu.com/p/25860846</a></p>\n</blockquote>\n<hr>\n<p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。</p>\n<ul>\n<li>官网传送门：<a href=\"https://eggjs.org\">https://eggjs.org</a></li>\n<li>GitHub：<a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg</a></li>\n<li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href=\"mailto:1030041592@qq.com\">1030041592@qq.com</a>)。期待你的加入！</li>\n</ul>\n<h2>特点</h2>\n<ul>\n<li><strong>『企业级的 Node.js Web 基础框架』</strong>，寓意 - 孕育新生。</li>\n<li>业界领先的 <strong>『微内核 + 插件机制』</strong>，专为团队架构师量身打造的 <strong>『框架定制』</strong> 能力。</li>\n<li>内建的安全机制与多进程管理模型。</li>\n<li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。</li>\n<li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。</li>\n<li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。</li>\n<li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。</li>\n</ul>\n<blockquote>\n<p>更详细的特点，以及 Node.js 在阿里的定位，可以参见： <a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></p>\n</blockquote>\n<h2>里程碑</h2>\n<ul>\n<li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。</li>\n<li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。</li>\n<li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。</li>\n<li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。</li>\n<li>2016 年 09 月，在 <a href=\"http://2016.jsconf.cn/\">JSConf China 2016</a> 上亮相并宣布开源。</li>\n<li>2017 年初，经过一周的<a href=\"https://cnodejs.org/topic/5870e9da04dcf9a706a745f0\">闭关直播写文档</a>，期待已久的 <a href=\"https://eggjs.org/\">官方文档</a> 诚意登场，足足近 30 篇。</li>\n<li>2017年 02 月，知乎问答：<a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></li>\n<li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending</strong> 周榜第三，Star 数增加 1k 多。</li>\n<li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。</li>\n</ul>\n<h2>成就</h2>\n<ul>\n<li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。</li>\n<li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。</li>\n<li>官网 UV 日均 300+ 。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png\" alt=\"screenshot.png\"></p>\n<ul>\n<li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png\" alt=\"screenshot.png\"></p>\n<h2>感言</h2>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png\" alt=\"screenshot.png\"></p>\n<h2>规划</h2>\n<ul>\n<li>Egg.js 英文文档翻译，欢迎加入 <a href=\"http://swift.gg/\">SwiftGG 翻译组</a> 发起的 <a href=\"https://github.com/eggjs/egg/issues/363\">Egg 文档翻译项目</a>。</li>\n<li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。</li>\n<li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href=\"/user/2\">@2</a> 。</li>\n</ul>\n</div>",
      "title": "Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架",
      "last_reply_at": "2017-05-05T07:29:49.340Z",
      "good": false,
      "top": true,
      "reply_count": 124,
      "visit_count": 23082,
      "create_at": "2017-03-21T10:06:45.487Z",
      "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars.githubusercontent.com/u/227713?v=3&s=120"
      }
    },
    {
      "id": "58ad76db7872ea0864fedfcc",
      "author_id": "51f0f267f4963ade0e08f503",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> ��件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\">[more]</a></li>\n<li>过滤 Html �签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
      "title": "饿了么大前端 Node.js 进阶教程",
      "last_reply_at": "2017-05-02T10:10:04.862Z",
      "good": true,
      "top": true,
      "reply_count": 120,
      "visit_count": 40951,
      "create_at": "2017-02-22T11:32:43.547Z",
      "author": {
        "loginname": "lellansin",
        "avatar_url": "https://avatars1.githubusercontent.com/u/2081487?v=3&s=120"
      }
    },
    {
      "id": "584a0c6f3ebad99b336b1ecc",
      "author_id": "55a668125a4b4a86539c2fd4",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h3>前言</h3>\n<p>项目灵感的最初来源是<a href=\"https://github.com/shinygang/Vue-cnodejs\">@shinygang</a>来自的Vue-cnodejs，\n感谢<a href=\"https://cnodejs.org/\">cnodejs</a>社区提供的API。\ngithub：<a href=\"https://github.com/lzxb/vue-cnode\">https://github.com/lzxb/vue-cnode</a></p>\n<h3>感悟</h3>\n<pre class=\"prettyprint\"><code>在vue-cnode升级vue2的时候，在公司内部已经有两个正式项目使用vue2，\n遇到的一个最难的问题，就是如何能在页面后退时还原数据和滚动条位置，\n虽然vue2内置了keep-alive组件，vue-router也提供了scrollBehavior方法进行设置，\n但是仍然无法满足需求，后来阅读vue-router的源码发现，\n每个页面都会自动在history.state对象中存储一个对应的key值，\n便利用这个特性实现了页面后退时，数据和滚动条还原，\n不过目前只是实现了页面的顶级组件还原，\n如果需要对顶级组件下的子组件实现数据还原，\n可以利用$options._scopeId来实现。\n哈哈，具体如何实现就要靠大家自己发挥想象力了\n</code></pre><h3>技术栈</h3>\n<pre class=\"prettyprint\"><code>基于vue2 + vue-router + vuex + ES6 + less + flex.css重写vue版cnode社区，使用webpack打包\n</code></pre><h3>使用项目</h3>\n<pre class=\"prettyprint\"><code>1.克隆项目：      git clone https:&#x2F;&#x2F;github.com&#x2F;lzxb&#x2F;vue-cnode.git\n2.安装nodejs\n3.安装依赖：      npm install\n4.启动服务：      npm run dev\n5.发布代码：      npm run dist\n</code></pre><h3>功能</h3>\n<ul>\n<li>[x] 首页列表，上拉加载</li>\n<li>[x] 主题详情，回复，点赞</li>\n<li>[x] 消息列表</li>\n<li>[x] 消息提醒</li>\n<li>[x] 个人主页</li>\n<li>[x] 用户信息</li>\n<li>[x] 登录</li>\n<li>[x] 退出</li>\n<li>[x] 关于</li>\n<li>[x] 页面后退，数据还原</li>\n<li>[x] 页面后台，滚动位置还原</li>\n<li>[x] ajax请求拦截器</li>\n<li>[x] 页面跳转，不再执行此页面的ajax请求回调方法</li>\n<li>[x] 启动图</li>\n</ul>\n<h3>项目目录说明</h3>\n<pre class=\"prettyprint\"><code>.\n|-- config                           &#x2F;&#x2F; 项目开发环境配置\n|   |-- index.js                     &#x2F;&#x2F; 项目打包部署配置\n|-- src                              &#x2F;&#x2F; 源码目录\n|   |-- components                   &#x2F;&#x2F; 公共组件\n|       |-- content.vue              &#x2F;&#x2F; 页面内容公共组件\n|       |-- data-null.vue            &#x2F;&#x2F; 数据为空时公共组件\n|       |-- footer.vue               &#x2F;&#x2F; 底部导航栏公共组件\n|       |-- header.vue               &#x2F;&#x2F; 页面头部公共组件\n|       |-- index.js                 &#x2F;&#x2F; 加载各种公共组件\n|       |-- loading.vue              &#x2F;&#x2F; 页面数据加载公共组件\n|   |-- config                       &#x2F;&#x2F; 路由配置和程序的基本信息配置\n|       |-- config.js                &#x2F;&#x2F; 配置项目的基本信息\n|       |-- routes.js                &#x2F;&#x2F; 配置页面路由\n|   |-- css                          &#x2F;&#x2F; 各种css文件\n|       |-- common.css               &#x2F;&#x2F; 全局通用css文件\n|   |-- iconfont                     &#x2F;&#x2F; 各种字体图标\n|   |-- images                       &#x2F;&#x2F; 公共图片\n|   |-- less                         &#x2F;&#x2F; 各种less文件\n|       |-- common.less              &#x2F;&#x2F; 全局通用less文件\n|       |-- config.less              &#x2F;&#x2F; 全局通用less配置文件\n|   |-- lib                          &#x2F;&#x2F; 各种插件\n|       |-- route-data               &#x2F;&#x2F; 实现页面后退数据还原，滚动位置还原\n|   |-- mixins                       &#x2F;&#x2F; 各种全局mixins\n|       |-- pull-list.js             &#x2F;&#x2F; 上拉加载\n|   |-- pages                        &#x2F;&#x2F; 各种页面组件\n|       |-- about                    &#x2F;&#x2F; 关于\n|       |-- index                    &#x2F;&#x2F; 首页\n|       |-- login                    &#x2F;&#x2F; 登录\n|       |-- my                       &#x2F;&#x2F; 我的主页，和消息列表\n|       |-- signout                  &#x2F;&#x2F; 退出\n|       |-- topic                    &#x2F;&#x2F; 主题详情，主题新建\n|       |-- user                     &#x2F;&#x2F; 查看用户资料\n|   |-- store                        &#x2F;&#x2F; vuex的状态管理\n|       |-- index.js                 &#x2F;&#x2F; 加载各种store模块\n|       |-- user.js                  &#x2F;&#x2F; 用户store\n|   |-- template                     &#x2F;&#x2F; 各种html文件\n|       |-- index.html               &#x2F;&#x2F; 程序入口html文件\n|   |-- util                         &#x2F;&#x2F; 公共的js方法\n|   |-- app.vue                      &#x2F;&#x2F; 页面入口文件\n|   |-- main.js                      &#x2F;&#x2F; 程序入口文件，加载各种公共组件\n|-- .babelrc                         &#x2F;&#x2F; ES6语法编译配置\n|-- webpack.config.js                &#x2F;&#x2F; 程序打包配置\n|-- server.js                        &#x2F;&#x2F; 开发时使用的服务器\n|-- README.md                        &#x2F;&#x2F; 项目说明\n|-- package.json                     &#x2F;&#x2F; 配置项目相关信息，通过执行 npm init 命令创建\n.\n</code></pre><h3><a href=\"http://lzxb.github.io/vue-cnode/\">扫一扫二维码查看效果</a></h3>\n<p><a href=\"http://lzxb.github.io/vue-cnode/\"><img src=\"https://github.com/lzxb/vue-cnode/raw/master/shot/QR-code.png\" alt=\"扫一扫二维码查看效果\"></a></p>\n</div>",
      "title": "基于vue2 + vue-router + vuex + ES6 + less + flex.css重写vue版cnode社区，使用webpack打包",
      "last_reply_at": "2017-05-10T08:18:12.236Z",
      "good": false,
      "top": false,
      "reply_count": 31,
      "visit_count": 2908,
      "create_at": "2016-12-09T01:44:15.980Z",
      "author": {
        "loginname": "1340641314",
        "avatar_url": "https://avatars3.githubusercontent.com/u/8424643?v=3&s=120"
      }
    },
    {
      "id": "590ae6bc52c3650e042a7f99",
      "author_id": "590a76b8782dbc4b183ed02b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>~</p>\n</div>",
      "title": "为何cnode的论坛都不是异步写的",
      "last_reply_at": "2017-05-10T08:12:48.173Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 486,
      "create_at": "2017-05-04T08:30:52.460Z",
      "author": {
        "loginname": "nasaplayer",
        "avatar_url": "https://avatars0.githubusercontent.com/u/26316854?v=3&s=120"
      }
    },
    {
      "id": "590801a1bbaf2f3f569be460",
      "author_id": "5907ff2e782dbc4b183ecf7d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>断断续续写了个单页面的博客系统,其实是想给我和我的小伙伴写日记用的,租了do服务器,express写接口,用nginx反向代理,也算是练练手。不得不说国外的服务器还是做单页面更好</p>\n</blockquote>\n<h2>vue前�部分</h2>\n<h3>前台依赖模块</h3>\n<pre class=\"prettyprint\"><code>vue-cli\nvue-router\nvuex\naxios\nmoment-timezone\nvue-waterfall\nwangeditor\n</code></pre><h3>功能模块</h3>\n<ul>\n<li>canvas粒子效果</li>\n<li>登录/注册</li>\n<li>个人中心</li>\n<li>添加文章</li>\n<li>编辑文章</li>\n<li>搜索文章</li>\n<li>下拉加载列表</li>\n<li>文章留言</li>\n<li>H5多图上传</li>\n<li>缩略图生成</li>\n<li>图片瀑布流布局</li>\n</ul>\n<h3>路由配置</h3>\n<pre class=\"prettyprint\"><code>import Vue from &#x27;vue&#x27;\nimport VueRouter from &#x27;vue-router&#x27;\n\nVue.use(VueRouter);\n\nimport store from &#x27;..&#x2F;store&#x2F;index&#x27;\n\nimport index from &#x27;..&#x2F;page&#x2F;index&#x27;\nimport dairy from &#x27;..&#x2F;page&#x2F;dairy&#x27;\nimport photo from &#x27;..&#x2F;page&#x2F;photo&#x27;\nimport login from &#x27;..&#x2F;page&#x2F;login&#x27;\nimport reg from &#x27;..&#x2F;page&#x2F;reg&#x27;\nimport user from &#x27;..&#x2F;page&#x2F;user&#x27;\nimport set from &#x27;..&#x2F;page&#x2F;set&#x27;\nimport page from &#x27;..&#x2F;page&#x2F;page&#x27;\nimport article from &#x27;..&#x2F;page&#x2F;article&#x27;\nimport edit from &#x27;..&#x2F;page&#x2F;edit&#x27;\n\nimport userIndex from &#x27;..&#x2F;components&#x2F;user&#x2F;index&#x27;\nimport userAlbum from &#x27;..&#x2F;components&#x2F;user&#x2F;album&#x27;\nimport userTogether from &#x27;..&#x2F;components&#x2F;user&#x2F;together&#x27;\nimport userInfo from &#x27;..&#x2F;components&#x2F;user&#x2F;info&#x27;\nimport setIndex from &#x27;..&#x2F;components&#x2F;set&#x2F;index&#x27;\nimport setFriend from &#x27;..&#x2F;components&#x2F;set&#x2F;friend&#x27;\nimport setPassword from &#x27;..&#x2F;components&#x2F;set&#x2F;password&#x27;\n\nconst routes = [{\n    path: &#x27;&#x2F;&#x27;,\n    component: index,\n    meta: { auth: false }\n}, {\n    path: &#x27;&#x2F;dairy&#x27;,\n    component: dairy,\n    meta: { auth: false }\n}, {\n    path: &#x27;&#x2F;photo&#x27;,\n    component: photo,\n    meta: { auth: false }\n}, {\n    path: &#x27;&#x2F;login&#x27;,\n    component: login,\n},{\n    path: &#x27;&#x2F;reg&#x27;,\n    component: reg,\n    meta: { auth: false }\n},{\n    path: &#x27;&#x2F;article&#x27;,\n    component: article,\n},{\n    path: &#x27;&#x2F;p&#x2F;:aid&#x27;,\n    name: &#x27;page&#x27;,\n    component: page,\n    meta: { auth: false }\n},{\n    path: &#x27;&#x2F;p&#x2F;:aid&#x2F;edit&#x27;,\n    name: &#x27;edit&#x27;,\n    component: edit,\n},{\n    path : &#x27;&#x2F;set&#x27;,\n    component : set,\n    children : [{\n        path: &#x27;&#x27;,\n        name: &#x27;setIndex&#x27;,\n        component : setIndex,\n    },{\n        path : &#x27;password&#x27;,\n        name: &#x27;setPassword&#x27;,\n        component : setPassword,\n    },{\n        path : &#x27;friend&#x27;,\n        name: &#x27;setFriend&#x27;,\n        component : setFriend,\n    }]\n}, {\n    path: &#x27;&#x2F;u&#x2F;:uid&#x27;,\n    component: user,\n    children: [{\n        path: &#x27;&#x27;,\n        name: &#x27;userIndex&#x27;,\n        component: userIndex,\n        meta: { auth: false }\n    }, {\n        path: &#x27;album&#x27;,\n        name: &#x27;userAlbum&#x27;,\n        component: userAlbum,\n        meta: { auth: false }\n    }, {\n        path: &#x27;together&#x27;,\n        name: &#x27;userTogether&#x27;,\n        component: userTogether,\n        meta: { auth: false }\n    }, {\n        path: &#x27;info&#x27;,\n        name: &#x27;userInfo&#x27;,\n        component: userInfo,\n        meta: { auth: false }\n    }]\n}];\n\nconst router = new VueRouter({\n    mode: &#x27;history&#x27;,\n    saveScrollPosition: true,\n    routes\n});\n\nrouter.beforeEach(({meta, path}, from, next) =&gt; {\n    var { auth = true } = meta;\n    var isLogin = Boolean(store.state.auth.token); &#x2F;&#x2F;true用户已登录， false用户未登录\n\n    if (auth &amp;&amp; !isLogin &amp;&amp; path !== &#x27;&#x2F;login&#x27;) {\n        return next({ path: &#x27;&#x2F;login&#x27; })\n    }\n    if(isLogin &amp;&amp; (path == &#x27;&#x2F;login&#x27; || path == &#x27;&#x2F;reg&#x27;)){\n        return next({ path: &#x27;&#x2F;&#x27; })\n    }\n    next()\n});\n\nexport default router;\n</code></pre><h3>前台运行程序</h3>\n<pre class=\"prettyprint\"><code>npm install\nnpm run dev\nhttp:&#x2F;&#x2F;localhost:8080&#x2F;\n</code></pre><h2>api后台部分</h2>\n<h3>后台依赖模块</h3>\n<pre class=\"prettyprint\"><code>express\nmongoose\nbluebird\njsonwebtoken\ngm            需安装ImageMagick\n</code></pre><h3>后台文件目录</h3>\n<pre class=\"prettyprint\"><code>│─ config\n│    └─    index.js\n│─ models\n│    ├─    album.model.js\n│    ├─    article.model.js\n│    ├─    comment.model.js\n│    └─    user.model.js\n├─ public&#x2F;uploads\n├─ routes\n│    ├─    album\n│    │        ├─    album.controller.js\n│    │        └─    index.js\n│    ├─    article\n│    │        ├─    article.controller.js\n│    │        └─    index.js\n│    ├─    auth\n│    │        ├─    local\n│    │        │        ├─    index.js\n│    │        │        └─    passport.js\n│    │        �─    auth.service.js\n│    │        └─    index.js\n│    ├─    comment\n│    │        ├─    comment.controller.js\n│    │        └─    index.js\n│    ├─    user\n│    │        ├─    user.controller.js\n│    │        └─    index.js\n│    └─    index.js\n├─ app.js             \n└─ package.json     \n</code></pre><h3>后台运行程序</h3>\n<pre class=\"prettyprint\"><code>npm install\n开启mongodb\nmongod --dbpath\nnode app\n</code></pre><h2>源码地址</h2>\n<p><a href=\"https://github.com/xuyd/vue-dairy\">前台界面</a>\n<a href=\"https://github.com/xuyd/dairy-api\">后台api</a>\n<a href=\"http://www.secretlove.top\">在线地址</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fh8bMMz55QHUov2UMBs5yG1IWU3B\" alt=\"689053382-5902a9e69ee4e_articlex.png\"></p>\n</div>",
      "title": "vue2 vuex 多人博客系统",
      "last_reply_at": "2017-05-10T08:12:26.372Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 595,
      "create_at": "2017-05-02T03:48:49.789Z",
      "author": {
        "loginname": "xuyd",
        "avatar_url": "https://avatars1.githubusercontent.com/u/19399469?v=3&s=120"
      }
    },
    {
      "id": "590bd8f60242b0dc030b3a59",
      "author_id": "58ddbda46f8b9bf02d1d0c93",
      "tab": "job",
      "content": "<div class=\"markdown-text\"><h3>猜一下这是谁写的歌词~</h3>\n<h3>集团总部 XO Group</h3>\n<p>XO Group (资讯集团The Knot) 是美国最大婚尚资讯集团，同时也是纽交所上市集团，股票代码为“XOXO”。旗下包括了网站、杂志、电视节目、相关书籍等诸多媒体资产，业务涵盖了婚尚资讯（<a href=\"http://theknot.com\">theknot.com</a>）、家居生活（<a href=\"http://thenest.com\">thenest.com</a>）、母婴产品（<a href=\"http://thebump.com\">thebump.com</a>），旗下网站月访问量均超过1亿次，注册用户超过300万，是美国在线交易额最大的婚尚网站！</p>\n<h2>诺特软件 GZ TheKnot</h2>\n<p>广州诺特软件开发有限公司成立于2009年7月，是XO Group Inc全资控股的软件开发中心，为XO Group的网站和客户提供技术支持。现已成长为2011-2012年度广东重点软件出口企业，2013-2015年广州市技术先进型企业。</p>\n<h2>薪酬福利</h2>\n<ul>\n<li>薪资优厚，快速晋升机会，五险一金均齐全（试用期即缴纳）；</li>\n<li>完善的培训体系，技术大牛导师和女神级别英语外教，优秀同事还能出国参加中美交流计划，让你华丽转身，跻身高手行列！</li>\n<li>丰富的生活福利，包括弹性工作制、高大上团队建设活动、轻奢公司旅游，还提供五 彩缤纷的零食柜，满足你的隐藏吃货属性；</li>\n<li>月度年度优秀奖励一个不少，同事融洽，领导贴心，跟优秀的人在一起！</li>\n<li>地处核心CBD，交通便利，更有开放式的舒适办公环境，</li>\n<li>按摩椅、健康体检、健康讲座，全方位呵护你的身心健康！</li>\n</ul>\n<h2>招聘岗位</h2>\n<h3>Node.js开发工程师</h3>\n<h4>【职位要求】</h4>\n<p>负责公司核心业务系统后台开发\n1.大专或以上学历，计算机或者相关专业毕业\n2.1年或以上NodeJS开发经验\n3.非常熟悉NodeJS LTS (4.2.x)的特性，有PostgreSQL开发经验\n4.熟悉Hapi系列modules，以及Chai系列和Sinon系列的单元测试modules\n5.熟悉基于Express框架的开发，熟练使用HTML/CSS/客户端JavaScript\n6.有AngularJS开发经验者优先考虑\n7.有Rabbit Message Queue的开发经验或者Elasitc Search开发经验者优先考虑\n8.能够阅读英文文档，具备一定英文编写能力\n9.良好的编程风格，独立思考有高度的工作责任感\n10.具有团队开发意识；良好的沟通协调能力，较好的语言表达能力，较好的文字处理能力</p>\n<h2>职位待遇</h2>\n<p>由你的能力及经验决定，待遇从优，详细面谈。</p>\n<h2>相关链接</h2>\n<p>[集团美国网站] (<a href=\"http://xogroupinc.com/\">http://xogroupinc.com/</a>)\n[集团中国网站] (<a href=\"http://www.tkcnsoft.com/\">http://www.tkcnsoft.com/</a>)\n联 系 人：HR &amp; Admin Department\n地 址：广州市天河路45号天伦大厦903\n电 话 : +8620 3830 3638 - 376\n简历可发往：[aqiu@xogrp.com] (<a href=\"mailto:aqiu@xogrp.com\">aqiu@xogrp.com</a>)</p>\n<h4>精彩缤纷的公司旅游</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2017/c3ca49f77989ce71b2eb9352c16d95f2.jpg!large\" alt></p>\n<h4>完善丰富的内外部培训</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2016/26b3c50f2139230892a6757cd6710219.jpg!large\" alt></p>\n<h4>开放宽松的办公环境</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2016/726e577ef434909803611481eec799d5.png!large\" alt></p>\n<h4>别开生面的公司活动</h4>\n<p><img src=\"https://ruby-china-files.b0.upaiyun.com/photo/2017/c6ca3d53af4fbd7d2049daf4712cd953.jpg!large\" alt></p>\n</div>",
      "title": "《广州招聘》-任“她们”多美丽，不及你矜贵-Node.js",
      "last_reply_at": "2017-05-10T08:11:05.778Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 217,
      "create_at": "2017-05-05T01:44:22.726Z",
      "author": {
        "loginname": "xogroupTim",
        "avatar_url": "https://avatars1.githubusercontent.com/u/26758199?v=3&s=120"
      }
    },
    {
      "id": "590fec57d371b6372a8af692",
      "author_id": "573212537abbbd520cb244b3",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>co.wrap = function(gen) {\n    var idt = gen(resume)\n    function resume() {\n        var args = arguments\n        process.nextTick(function() {\n            var obj = idt.next(args).value\n            if (obj &amp;&amp; isPromise(obj))\n                obj.then(\n                  (res) =&gt; {\n                    resume(null, res)\n                  },\n                  (err) =&gt; resume(err)\n                )\n        })\n    }\n    return resume\n}\nco.run = function(gen) {\n    co.wrap(gen)()\n}\nco.run(function * ($) {\n\t&#x2F;&#x2F; yield\n})\n</code></pre><p>对应这句代码我不是很理解: <code>resume(null, res)</code>\n望指教</p>\n<p>原来我不理解是因为:\n不懂为什么要递归呢？\n是为了继续运行生成器函数，直到返回 <code>Object { value: undefined, done: true }</code>\n<code>resume(null, res)</code>传的参数是干什么用的呢？\n实际上是将结果传回去，类似这个</p>\n<pre class=\"prettyprint language-js\"><code>function* gen() {\n  while(true) {\n    var value = yield null;\n    console.log(value);\n  }\n}\n\nvar g = gen();\ng.next(1); \n&#x2F;&#x2F; &quot;{ value: null, done: false }&quot;\ng.next(2); \n&#x2F;&#x2F; &quot;{ value: null, done: false }&quot;\n&#x2F;&#x2F; 2\n</code></pre><p>等我想好了，我会告诉大家使用process.nextTick( )的意义。</p>\n</div>",
      "title": "能讲清楚这段代码的不是大牛，就是即将迈向大牛的小牛！",
      "last_reply_at": "2017-05-10T08:04:54.502Z",
      "good": false,
      "top": false,
      "reply_count": 20,
      "visit_count": 893,
      "create_at": "2017-05-08T03:56:07.304Z",
      "author": {
        "loginname": "dlyt",
        "avatar_url": "https://avatars3.githubusercontent.com/u/18431616?v=3&s=120"
      }
    },
    {
      "id": "591162809e32cc84569a6cbd",
      "author_id": "58e8b3fb7574bc6b05b44553",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>nodejs里有没有可以存储callback函数的缓冲队列?\n现在是想把收到的请求的参数连同callback函数一起存储在一个队列中, 一次从队列里取出20个进行处理(调用的api一次处理20个参数), 然后再根据结果分别调用那20个callback函数.\n不知道有没有现成的工具或者方法?</p>\n</div>",
      "title": "nodejs里有没有可以存储callback函数的缓冲队列?",
      "last_reply_at": "2017-05-10T08:01:27.329Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 167,
      "create_at": "2017-05-09T06:32:32.036Z",
      "author": {
        "loginname": "Eeylx",
        "avatar_url": "https://avatars3.githubusercontent.com/u/17894833?v=3&s=120"
      }
    },
    {
      "id": "5912ae379e32cc84569a6d3d",
      "author_id": "587ac91b2967eeb01aafe7ac",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我现在在做一个项目，用nodejs作为应用的中间层，前端通过superagent和nodejs层交互，nodejs通过superagent和数据层交互，但是在登录这一块我有点纠结，因为中间隔着nodejs，所有交互有都是异步的，所以在登录成功后后台产生的cookie或者token究竟要怎么让前端接收到呢？nodejs应该是不能把数据层响应的东西res全部什么也不处理直接返回给前端的吧，包括响应头什么的，所以如果是这样的话，是要在nodejs层把session id或者token什么的手动提取出来再设置为前端的响应头吗？如果不是那要怎么解决呢？</p>\n</div>",
      "title": "nodejs做中间层如何进行权限认证",
      "last_reply_at": "2017-05-10T08:00:38.775Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 124,
      "create_at": "2017-05-10T06:07:51.649Z",
      "author": {
        "loginname": "sunhaoxiang",
        "avatar_url": "https://avatars3.githubusercontent.com/u/24645480?v=3&s=120"
      }
    },
    {
      "id": "5911cb163504ce1c2ac45a1d",
      "author_id": "58eb1bb18cda074427315672",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如题，使用<code>vue-server-renderer</code>。\n在vuex actions中异步获取数据，会卡住无响应\n<img src=\"//dn-cnode.qbox.me/FnqfpEL8A64Fbh8XGjueXzmqvKjU\" alt=\"image.png\">\n但是加上locahost以后就可以\n<img src=\"//dn-cnode.qbox.me/Fm_MJKulk8Hs1zks01l1zoUw4k-U\" alt=\"image.png\"></p>\n<p>而且如果把 这段代码从actons 中拿出来就不会卡住\n<code>Vue.http.post('/article/' + id).then(res =&gt; { commit('SET_ATICLE', res.body) });</code></p>\n</div>",
      "title": "使用vue2服务端渲染的时候，如何在服务端请求数据",
      "last_reply_at": "2017-05-10T07:57:21.383Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 119,
      "create_at": "2017-05-09T13:58:46.441Z",
      "author": {
        "loginname": "hifarer",
        "avatar_url": "https://avatars2.githubusercontent.com/u/6140573?v=3&s=120"
      }
    },
    {
      "id": "5912c29bd371b6372a8af79a",
      "author_id": "590a76b8782dbc4b183ed02b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我知道的是关闭浏览器可以自动监听，现在点击按钮断开/离线状态，不知道如何做\n客户端关闭浏览器，会自动触发socket.on(‘disconnect’…</p>\n<p>现在想通过按钮点击，失去连接 ，这种不行\n$(’#dealBtn’).on(‘click’,function(){\n\tsocket.emit(‘disconnect’);\n\tconsole.log(‘点击断开’);\n});</p>\n<p>换一个思路发起自定义事件，然后服务端监听\nsocket.on(‘user cut’,function(){\n\t\tsocket.close();  <a href=\"//socket.end\">//socket.end</a>()都没有这种方法\n\t});</p>\n</div>",
      "title": "请问客户端如何通过点击按钮主动断开连接",
      "last_reply_at": "2017-05-10T07:43:54.531Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 50,
      "create_at": "2017-05-10T07:34:51.200Z",
      "author": {
        "loginname": "nasaplayer",
        "avatar_url": "https://avatars0.githubusercontent.com/u/26316854?v=3&s=120"
      }
    },
    {
      "id": "5912887bba8670562a40eeb6",
      "author_id": "58f023c5e54976e847e0a039",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>在用nodejs做一个项目，   项目要用到类似cnode这样的markdown 编辑器， 我现在用的simditor， 但是文档太少了， 各位有没有什么好的推荐一下</p>\n</div>",
      "title": "nodejs，富文本编辑器",
      "last_reply_at": "2017-05-10T07:24:43.333Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 162,
      "create_at": "2017-05-10T03:26:51.451Z",
      "author": {
        "loginname": "WUSO01",
        "avatar_url": "https://avatars3.githubusercontent.com/u/21070775?v=3&s=120"
      }
    },
    {
      "id": "59126fd4ba8670562a40eea3",
      "author_id": "58df754d6f8b9bf02d1d0d39",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>写了一段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>\nconst abc = async function(){\n\tawait request(testdata)\n\t\t.then(data=&gt;{\n\t\t\tconsole.log(data)\n\t\t})\n\t\t.catch(err=&gt;{\n\t\t\tconsole.log(err)\n\t\t})\n}\n\n</code></pre><p>一位同事看到我这样写以后，给我提出了改进的建议</p>\n<pre class=\"prettyprint language-javascript\"><code> const abc = async function(){\n try{\n   let data=\tawait request(testdata)\n   console.log(data);\n }\n catch(ex){\n \tconsole.log(ex);\n }\n}\n</code></pre><p>当然是实际的业务代码比上面的还是要复杂一些的。第二种使用<code>try...catch</code>的方式确实是优雅一些。所以就对自己的代码质量产生了担心，所以想问下大家平时在开发过程中怎么提高自己的代码质量呢？</p>\n</div>",
      "title": "如果提高自己的Nodejs代码质量",
      "last_reply_at": "2017-05-10T06:46:54.384Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 213,
      "create_at": "2017-05-10T01:41:40.147Z",
      "author": {
        "loginname": "zhiqiang21",
        "avatar_url": "https://avatars2.githubusercontent.com/u/3990411?v=3&s=120"
      }
    },
    {
      "id": "578052ee69d72f545483ca46",
      "author_id": "578050ef3b501f7054982e50",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>求：\n我已经安装imagemagick 和graphicsmagick 在cmd中测试都有效果，也能输出版本和命令啥的，环境变量已配置\n但是在node里面调这个模块的时候\ngraphicsmagick会出现  [Error: Could not execute GraphicsMagick/ImageMagick: gm “identify” “-ping” “-format” “%[EXIF:Orientation]” “./222.jpg” this most likely means the gm/convert binaries can’t be found]</p>\n<p>他报this most likely means the gm/convert binaries can’t be found</p>\n<p>magemagick他会报{ [Error: Command failed: Ч - -resize\n] code: 4, signal: null }</p>\n<p>求大神解救下，我查了很多资料就是w7系统的有自带的convert命令，和imageMagick命令冲突，但是不知道这么解决，这答案可能也不是正确的，求大神帮帮忙实在是没招儿了，谢谢\n我用的是w7系统</p>\n</div>",
      "title": "gm图片处理模块儿无法正常使用",
      "last_reply_at": "2017-05-10T06:39:54.203Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 2563,
      "create_at": "2016-07-09T01:27:10.573Z",
      "author": {
        "loginname": "santant",
        "avatar_url": "https://avatars.githubusercontent.com/u/16360586?v=3&s=120"
      }
    },
    {
      "id": "5912b472d371b6372a8af78d",
      "author_id": "54475fdf649ac9220757b8ed",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://git-scm.com/\">Git 2.13</a> 发布了，其部分更新内容有：</p>\n<ul>\n<li>修复了 git shell 安全漏洞\n此安全漏洞只影响自行搭建 Git 托管服务并配置了 git shell 的用户，Coding 用户（包括 Coding 平台版及企业版用户）不受该漏洞影响，关于此漏洞的详情可以 <a href=\"http://t.cn/RaIgJCo\">点击此处进一步了解</a>。</li>\n<li>增强了 SHA-1 碰撞检测\n您可能已经听说研究人员最近发现 SHA-1 中的第一个成功碰撞，Git 用于识别对象的哈希函数。他们的技术最终可能被用来对 Git 用户进行基于碰撞的攻击。幸运的是，研究人员还提供了一种方法来检测正在尝试利用这种技术来创建碰撞的内容。Git 2.13 碰撞检测 SHA-1 实现是默认开启的，代码内置在 Git 中，所以不需要安装任何附加的依赖项。</li>\n<li>改进的按需配置\n您可以在系统级别，用户级别，存储库级别或单个命令级别进行调用单独配置（使用 git -c ）中。 通常，在更具体的位置中找到的配置文件将覆盖在较上级的位置中找到的相同配置文件。 如在存储库的 <code>.git / config</code> 文件中设置 user.email 将覆盖您可能在 <code>〜/ .gitconfig</code>中设置的用户级配置。</li>\n<li>更智能的路径功能\nPathspecs 支持文字路径，前缀或通配符，如：</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ git log Documentation&#x2F;      #  Documentation&#x2F; 目录下所有文件\n$ git log &#x27;*.c&#x27;               # 当前目录下所有 C 文件\n</code></pre><ul>\n<li>更多的命令已经学会了在过去几个版本的 Git 中递归到子模块，包括 checkout，grep 和 ls-files。git status --short 现在还会输出有关子模块的更多信息。</li>\n</ul>\n<p>此次更新包括了 700 多个 commit，更多更新内容请浏览 <a href=\"https://github.com/git/git/blob/v2.13.0/Documentation/RelNotes/2.13.0.txt\">完整的发行说明</a> ，提交 git 的 bug 请使用英文发送邮件到 <a href=\"mailto:git@vger.kernel.org\">git@vger.kernel.org</a></p>\n</div>",
      "title": "Git 2.13 发布",
      "last_reply_at": "2017-05-10T06:34:26.511Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 78,
      "create_at": "2017-05-10T06:34:26.511Z",
      "author": {
        "loginname": "zengliqi",
        "avatar_url": "https://avatars.githubusercontent.com/u/9347370?v=3&s=120"
      }
    },
    {
      "id": "58821efc171f3bc843f600b6",
      "author_id": "57f9d5a30bab808265185bd6",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>postModel.findOne({\n      &quot;name&quot;: name,\n    }, function(err, doc) {\n      if(err){\n        return callback(err);\n      }\n      delete doc._id; &#x2F;&#x2F;删除掉原来的_id, 这里删除掉_id后，其doc._id仍然存在\n      console.log(doc.id);\n      &#x2F;&#x2F; etc.****\n})\n</code></pre><p>如上所述，我在找到那个doc后想要删除它的<code>_id</code>属性，然后更新它自己。继而通过doc的一些属性得到另外一个<code>document</code>，然后保存。这样后面一个<code>document</code>就复制了doc的一些属性（通过复制）。问题是</p>\n<ul>\n<li>使用<code>delete doc._id</code>后，其依然存在，这样我得到的<code>document</code>的<code>_id</code>和doc的<code>_id</code>是一样的，形成了覆盖。</li>\n<li>我在<code>new Schema({ _id: Schema.Types.ObjectId })</code>添加了<code>_id</code>字段后，得到的结果是一样的。\n<img src=\"//dn-cnode.qbox.me/Fvw-2-gv0gdHOB3ILxy0jkP0BCjk\" alt=\"360反馈意见截图16411209109133124.png\"></li>\n<li>如果使用mongodb来操作，这样就没有问题，得到的结果是<code>undefined</code>。</li>\n</ul>\n<h3>我该怎么做？ 有会的哥哥姐姐帮忙解答一下吗</h3>\n</div>",
      "title": "mongoose查询数据库找到文档删除其_id无效",
      "last_reply_at": "2017-05-10T06:14:48.987Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 488,
      "create_at": "2017-01-20T14:30:20.119Z",
      "author": {
        "loginname": "yuwanlin",
        "avatar_url": "https://avatars.githubusercontent.com/u/18443683?v=3&s=120"
      }
    },
    {
      "id": "590f3b603504ce1c2ac4594f",
      "author_id": "58eb6a973145ae3f25fe614f",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>贴下Log:</p>\n<pre class=\"prettyprint\"><code>&lt;-- GET &#x2F;apiV2&#x2F;app&#x2F;listSpecificProd?envType=1&amp;pageNo=1&amp;platform=1\n  --&gt; GET &#x2F;apiV2&#x2F;app&#x2F;listSpecificProd?envType=1&amp;pageNo=1&amp;platform=1 200 2ms 43b\n  &lt;-- GET &#x2F;apiV2&#x2F;app&#x2F;listSpecificProd?envType=1&amp;pageNo=1&amp;platform=1&amp;prodType=1001\n  --&gt; GET &#x2F;apiV2&#x2F;app&#x2F;listSpecificProd?envType=1&amp;pageNo=1&amp;platform=1&amp;prodType=1001 404 3ms -\n</code></pre></div>",
      "title": "太奇怪了！！Koa2 Get请求，多加一个参数就返回404，",
      "last_reply_at": "2017-05-10T06:13:05.974Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 231,
      "create_at": "2017-05-07T15:21:04.535Z",
      "author": {
        "loginname": "pandaApe",
        "avatar_url": "https://avatars0.githubusercontent.com/u/6929938?v=3&s=120"
      }
    },
    {
      "id": "5911c90f9e32cc84569a6cf4",
      "author_id": "53b25565399ed9e07d1e8793",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>已经尝试了ejs，是可以实现的，其它模板没有试过</p>\n<p>目前在用nunjucks，这个模板以前版本有个express-pjaxify可以实现pjax无刷新更新页面，现在nunjucks，express，pjax版本都高了，不能用了，作者也不更新了</p>\n<p>其它的模板没试过，在这求一下折腾过的小伙伴分享一下折腾的经验</p>\n</div>",
      "title": "求nodejs可以使用pjax的模板",
      "last_reply_at": "2017-05-10T06:02:34.325Z",
      "good": false,
      "top": false,
      "reply_count": 10,
      "visit_count": 171,
      "create_at": "2017-05-09T13:50:07.230Z",
      "author": {
        "loginname": "liygheart",
        "avatar_url": "https://avatars1.githubusercontent.com/u/6915570?v=3&s=120"
      }
    },
    {
      "id": "59113acd3504ce1c2ac459d6",
      "author_id": "57820f1d49e4faa95429c603",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>基于 react-native+redux 的高仿 V2EX 客户端开源项目</p>\n<p>github 传送门:  <a href=\"https://github.com/seawind8888/react-native-v2ex.git\">https://github.com/seawind8888/react-native-v2ex.git</a>\n（欢迎star&amp;fork）</p>\n<h3>安装配置</h3>\n<h4>1.第一步</h4>\n<pre class=\"prettyprint\"><code>git clone  https:&#x2F;&#x2F;github.com&#x2F;seawind8888&#x2F;react-native-v2ex.git\n</code></pre><h4>2.第二步</h4>\n<pre class=\"prettyprint\"><code>cd v2ex_demo\n</code></pre><h4>3.第三步</h4>\n<pre class=\"prettyprint\"><code>npm install\n</code></pre><h4>4.第四步</h4>\n<pre class=\"prettyprint\"><code>1.运行 Android 版本\nMac OS X:react-native run-android  or Windows OS:react-native start and react-native run-android\n2.运行 iOS 版本\nMac OS X:react-native run-ios or  xcode open project and run project\n</code></pre><h3>运行效果</h3>\n<p><img src=\"//dn-cnode.qbox.me/FnpEBTln4v1V3C4_mEzYSl8ZJBxq\" alt=\"v2ex_1.gif\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FhKlQTQ5sqt2d6NrnHuDbPDT54D7\" alt=\"v2ex_2.gif\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Fo2XfDiFNaTFCDdJK30q7_kayT9B\" alt=\"v2ex_3.gif\"></p>\n<h3>使用组件</h3>\n<pre class=\"prettyprint\"><code>1.react-native-side-menu  \n2.react-native-swiper  \n3.react-native-vector-icons\n4.react-redux\n5.redux\n6.redux-thunk\n</code></pre></div>",
      "title": "基于 react-native+redux 开发的高仿 V2EX 客户端",
      "last_reply_at": "2017-05-10T05:27:41.309Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 273,
      "create_at": "2017-05-09T03:43:09.385Z",
      "author": {
        "loginname": "seawind8888",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16148014?v=3&s=120"
      }
    },
    {
      "id": "59102016d371b6372a8af6aa",
      "author_id": "585eae74708f21aa5db0ecc4",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>jquery 动画插件哪个好用啊\n求一款效果多的jquery动画插件</p>\n</div>",
      "title": "jquery 动画插件哪个好用啊",
      "last_reply_at": "2017-05-10T05:19:02.044Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 178,
      "create_at": "2017-05-08T07:36:54.451Z",
      "author": {
        "loginname": "qiphon",
        "avatar_url": "https://avatars1.githubusercontent.com/u/24565078?v=3&s=120"
      }
    },
    {
      "id": "591130d6ba8670562a40ee44",
      "author_id": "59101cdcd371b6372a8af6a9",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>只是一个js小白，在做一个程序的时候总是想到要连接后台跟数据库，想到PHP麻烦就找到了node.js.</p>\n<p>怎样继续学下去啊。好迷茫。</p>\n</div>",
      "title": "从深入浅出Node.js中入门可以吗？",
      "last_reply_at": "2017-05-10T04:46:50.504Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 359,
      "create_at": "2017-05-09T03:00:38.080Z",
      "author": {
        "loginname": "gregLINm",
        "avatar_url": "https://avatars3.githubusercontent.com/u/26732117?v=3&s=120"
      }
    },
    {
      "id": "59117900ba8670562a40ee5a",
      "author_id": "58341651bde2b59e06141e3c",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>“路漫漫其修远兮，吾将上下而求索”\n感兴趣有时间的小伙伴，直播间等你们。\n<img src=\"//dn-cnode.qbox.me/FpLSsFpVEG9_wKzOZNZzzqPGvkSq\" alt=\"子慕CSS.jpg\"></p>\n</div>",
      "title": "欲练JS，必先攻CSS——我的前端修行之路（直播）",
      "last_reply_at": "2017-05-10T04:25:27.614Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 307,
      "create_at": "2017-05-09T08:08:32.639Z",
      "author": {
        "loginname": "erbajie",
        "avatar_url": "https://avatars1.githubusercontent.com/u/23623771?v=3&s=120"
      }
    },
    {
      "id": "590770b55bb7efe417431f28",
      "author_id": "5907703b5bb7efe417431f27",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FgnmbKsMfM59aS-OdDY60o-G0KCo\" alt=\"1645151993-59057c694d2a9_articlex.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FtlKbJ1NtDYrfqiLaAlfegRjVEAF\" alt=\"1577543365-59057c5536b15_articlex.png\"></p>\n<p>github: <a href=\"https://github.com/chanywn/OneToOneChat\">https://github.com/chanywn/OneToOneChat</a></p>\n<h3>如何使用</h3>\n<ol>\n<li>安装 node.js</li>\n<li>执行 npm install</li>\n<li>执行 node server.js</li>\n<li>访问 <a href=\"http://localhost:3000\">http://localhost:3000</a></li>\n</ol>\n<p>使用 socket.io做多对多聊天很容易，做一对一的可以借鉴的资料却很少，如果你也想做一对一的聊天，我这个小 demo 希望对你帮助。\n提示一点，核心的原理就是把用户的 socket id 保存起来，想和谁聊天，就使用对方的 socket id 发给他消息。\n发送信息的格式可以是这样的\n<img src=\"//dn-cnode.qbox.me/FqEghPmBY30XV3NgOwcaL-1XX7oN\" alt=\"untitled1.png\">\n谁给谁发了什么类型的消息\n客户端收到后，就找这个人，并把消息显示出来（可以看到我这里是使用用户名来做用户标识的，如果是正式项目可以采用用户id）</p>\n<h2>演示</h2>\n<p>已过期</p>\n</div>",
      "title": "基于socket.io实现的一对一聊天服务器和客户端",
      "last_reply_at": "2017-05-10T03:46:39.116Z",
      "good": false,
      "top": false,
      "reply_count": 17,
      "visit_count": 937,
      "create_at": "2017-05-01T17:30:29.155Z",
      "author": {
        "loginname": "chanywn",
        "avatar_url": "https://avatars2.githubusercontent.com/u/28001537?v=3&s=120"
      }
    },
    {
      "id": "591135c3ba8670562a40ee47",
      "author_id": "59006da0bbaf2f3f569be2f2",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>需求：\n<a href=\"http://www.test.com\">www.test.com</a>                 -&gt;  127.0.0.1:2346\n<a href=\"http://www.test.com/project1\">www.test.com/project1</a>   -&gt;  127.0.0.1:3000\n<a href=\"http://www.test.com/project2\">www.test.com/project2</a>   -&gt;  127.0.0.1:4000</p>\n<p><strong>请问nginx的配置文件该怎么写</strong>，目前写的有问题</p>\n<p><img src=\"//dn-cnode.qbox.me/FtfhQ23GRrRnWWOYcrBZ9XY5Sb0g\" alt=\"untitled1.png\"></p>\n</div>",
      "title": "ngnix如何通过二级目录代理多个nodejs应用？",
      "last_reply_at": "2017-05-10T03:38:55.769Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 203,
      "create_at": "2017-05-09T03:21:39.816Z",
      "author": {
        "loginname": "flute",
        "avatar_url": "https://avatars0.githubusercontent.com/u/5842406?v=3&s=120"
      }
    },
    {
      "id": "59112d5a9e32cc84569a6c97",
      "author_id": "53b25565399ed9e07d1e8793",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>记得之前有个大大写了个chrome插件，可以获取通知，那个对浏览器有要求，我用油猴子写了个脚本的通知插件，不过要一直开着页面，反正都有局限性，其实开始想用socket.io集成进nodeclub代码的，不知道 <a href=\"/user/alsotang\">@alsotang</a> 大大会不会合并，反正这个简单，就先实现了再说 : )</p>\n<p>脚本代码：<a href=\"https://greasyfork.org/zh-CN/scripts/29603-cnodejs%E7%AB%99%E5%86%85%E9%80%9A%E7%9F%A5/\">https://greasyfork.org/zh-CN/scripts/29603-cnodejs站内通知/</a>\n使用需要安装浏览器插件：<a href=\"http://tampermonkey.net/\">http://tampermonkey.net/</a>\n功能：就是不用刷新页面，脚本每分钟会自动请求一下通知的接口，如果有通知，会在未读消息前出现提示，脚本对页面样式做了点修改，将页面头固定在顶部了，目的方便看通知数</p>\n<p><strong>插件的性能不保证，可能会对浏览cnodejs站造成一定的影响</strong></p>\n<p><img src=\"//dn-cnode.qbox.me/Fm8ianWwszgY4oBwsEBjK9iPNdPp\" alt=\"图片.png\">\n<img src=\"//dn-cnode.qbox.me/FuxqWpJJODGMGV3xqyDjJyP__JQI\" alt=\"图片.png\"></p>\n</div>",
      "title": "给CNodeJS站写了一个站内通知的脚本，有兴趣的可以装一下",
      "last_reply_at": "2017-05-10T03:28:14.257Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 314,
      "create_at": "2017-05-09T02:45:46.441Z",
      "author": {
        "loginname": "liygheart",
        "avatar_url": "https://avatars1.githubusercontent.com/u/6915570?v=3&s=120"
      }
    },
    {
      "id": "590ce994d371b6372a8af601",
      "author_id": "57d216e13d3520a5387c2b53",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>命令窗口中显示找不到<img src=\"//dn-cnode.qbox.me/FqpkJ4Pi0v1ynwDoR4TXesHskiRb\" alt=\"1.png\">\napp.js <img src=\"//dn-cnode.qbox.me/FmyIXwSCldWJ_ZTSfwPaLuzmKXWt\" alt=\"4.png\"></p>\n<p>路由层<img src=\"//dn-cnode.qbox.me/Fml2QjXSWZRmDLks2FOeplL3YnTz\" alt=\"2.png\"></p>\n<p>控制器层<img src=\"//dn-cnode.qbox.me/FphaigVKjnCeQh6AaCtSeW4dkmq0\" alt=\"3.png\"></p>\n<p>请求页面在的目录<img src=\"//dn-cnode.qbox.me/FmyjPOh1neqvFjqPXEkRkJBU-DMT\" alt=\"5.png\"></p>\n</div>",
      "title": "大家好 谁能帮我看一眼 为什么总是提示找不到页面",
      "last_reply_at": "2017-05-10T03:24:34.660Z",
      "good": false,
      "top": false,
      "reply_count": 18,
      "visit_count": 455,
      "create_at": "2017-05-05T21:07:32.133Z",
      "author": {
        "loginname": "a69694510",
        "avatar_url": "https://avatars2.githubusercontent.com/u/20507053?v=3&s=120"
      }
    },
    {
      "id": "59117f22ba8670562a40ee60",
      "author_id": "59117e76ba8670562a40ee5e",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>首先我承认，这是一篇广告贴。我在广告我的新公众号。</p>\n<p>但光是广告还不行，我还是要在这里写一些干货。</p>\n<p>这个公众号叫做“全栈笔记 Fullstack Note”，网址是 <a href=\"http://fsnote.co\">http://fsnote.co</a> 。每天（或者每两天），我会推荐3篇左右优质的全栈开发文章给大家，英文为主。对于每篇文章，我会附上简短的介绍和心得，以及预计阅读时间。希望能帮助全栈开发工程师们成长，也帮助我自己成长。\n<img src=\"//dn-cnode.qbox.me/FiOJCtxhDxFGr1i8Un0inm_os0UT\" alt=\"590c3b5a-MSZJ9.png\"></p>\n<p>我作为一个Ruby on Rails全栈工程师有4年左右的时间了，这期间做过也做过 Android iOS，也做过设计图纸转HTML+CSS，也曾经当过公司唯一一个工程师。我不能说自己的技术实力有多高，毕竟我很少参与各种开源项目，水平有限。不过，当使用RoR几年之后，随着对框架的慢慢熟悉，也渐渐缺乏了些新鲜感和挑战性。而在工作中，和团队合作的过程中发现，如果缺少其他发面的知识，比如<strong>负载均衡、CDN、系统架构，DevOps</strong>，很难称自己是优秀的全栈工程师。</p>\n<p>所以对于全栈网站工程师，绝不仅仅是使用自己熟悉的框架进行业务逻辑开发，其实要求挺高。需要懂得一点前端技术，中间业务逻辑，懂得后端服务器，数据库。每天有很多东西值得关注和学习。</p>\n<p>全栈笔记是我思考之后开始的一个side project。考虑到面向的读者应该是使用不同框架的工程师，所以我分享的文章不会偏向任何一个框架，更不会单纯介绍一段代码如何写。我会侧重于全栈工程师应该具备的<strong>基本知识储备，以及一些可以拓展见识，对工作有帮助的信息</strong>。这也算是我对“全栈”的理解。</p>\n<p>最后，放上公众号的二维码。我曾经做过不少side project，都不了了之。希望“全栈笔记”可以坚持下去。也希望大家多多支持，提出宝贵建议。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fil06YtDk8AROxX_IpduL2I_idNk\" alt=\"590c3b52-AxFUq.jpg\"></p>\n</div>",
      "title": "全栈笔记：每天推荐几篇优质的全栈开发文章 (以及我对全栈的看法)",
      "last_reply_at": "2017-05-10T03:09:16.309Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 300,
      "create_at": "2017-05-09T08:34:42.577Z",
      "author": {
        "loginname": "allenlsy",
        "avatar_url": "https://avatars3.githubusercontent.com/u/872876?v=3&s=120"
      }
    },
    {
      "id": "59112a433504ce1c2ac459d1",
      "author_id": "57aaad434653749872ec6f6b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>公司业务需求，需要去sql server中提取存在里面的图片，并把它保存在本地\n数据中的该表结构如图  <img src=\"//dn-cnode.qbox.me/FpwZlfTSS9VZsIe7wQRQz_jMA8wf\" alt=\"image.png\">\n请问各位大神 有啥好办法么，我直接拿出来去存图片是打不开的。然后怀疑是sqlserver中的编码问题，sqlserver是GBK编码， 但是用iconv去转的时候 提示无效的字符串序列<img src=\"//dn-cnode.qbox.me/FuVEFJiNZs3ygUbEfSLJeI0n8hAr\" alt=\"image.png\"></p>\n</div>",
      "title": "请问nodejs 提取sql server  中image字段类型的buffer数据流，并且将其转为图片的办法",
      "last_reply_at": "2017-05-10T03:02:07.973Z",
      "good": false,
      "top": false,
      "reply_count": 13,
      "visit_count": 278,
      "create_at": "2017-05-09T02:32:35.231Z",
      "author": {
        "loginname": "xumjs8623",
        "avatar_url": "https://avatars3.githubusercontent.com/u/12467615?v=3&s=120"
      }
    },
    {
      "id": "590df016cfb837012a59b44f",
      "author_id": "58f8d50dbbaf2f3f569be0c7",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>Node版本7.8.0\nnpm 4.2.0\n安装electron 1.6.6版本报错</p>\n<pre class=\"prettyprint\"><code>&gt; electron@1.6.6 postinstall &#x2F;Users&#x2F;xx&#x2F;node_modules&#x2F;electron\n&gt; node install.js\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;Users&#x2F;chenlei&#x2F;node_modules&#x2F;electron&#x2F;install.js:47\n  throw err\n  ^\n\nError: connect ETIMEDOUT 54.231.34.41:443\n    at Object.exports._errnoException (util.js:1034:11)\n    at exports._exceptionWithHostPort (util.js:1057:20)\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1096:14)\nnpm WARN vue-loader@8.7.0 requires a peer of babel-runtime@^6.0.0 but none was installed.\nnpm WARN chenlei@1.0.0 No description\nnpm WARN chenlei@1.0.0 No repository field.\nnpm ERR! Darwin 15.4.0\nnpm ERR! argv &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node&quot; &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm&quot; &quot;install&quot; &quot;electron&quot; &quot;--save-dev&quot;\nnpm ERR! node v7.8.0\nnpm ERR! npm  v4.2.0\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\n</code></pre><p>github上找到关于报错的原因  <a href=\"https://github.com/electron/electron/issues/9323\">https://github.com/electron/electron/issues/9323</a>   是extract-zip的bug 具体的解决方案我看好像是改成1.6.5就可以\n但是我现在遇到的问题是 全局安装报错 然后项目就没有了  没法改package.json  然后.npm 缓存里的信息我改了 npm貌似不从缓存里拿信息 还是没用\n已经被这个问题卡了两天了  求大家帮助</p>\n</div>",
      "title": "electron 安装报错",
      "last_reply_at": "2017-05-10T02:57:45.764Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 227,
      "create_at": "2017-05-06T15:47:34.452Z",
      "author": {
        "loginname": "biuge",
        "avatar_url": "https://avatars2.githubusercontent.com/u/11517747?v=3&s=120"
      }
    },
    {
      "id": "5911bbfd9e32cc84569a6cf2",
      "author_id": "58d7698be9ab80d02d37709a",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>使用koa2重写的nodeclub，除了api功能外，其它都已实现</p>\n<p>github地址: <a href=\"https://github.com/xiedacon/nodeclub-koa\">https://github.com/xiedacon/nodeclub-koa</a></p>\n</div>",
      "title": "使用koa2重写的nodeclub",
      "last_reply_at": "2017-05-10T02:49:16.246Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 187,
      "create_at": "2017-05-09T12:54:21.226Z",
      "author": {
        "loginname": "xiedacon",
        "avatar_url": "https://avatars2.githubusercontent.com/u/14571125?v=3&s=120"
      }
    },
    {
      "id": "59119ebd9e32cc84569a6cde",
      "author_id": "54c5e08c0d075f173d433fc2",
      "tab": "job",
      "content": "<div class=\"markdown-text\"><p>前端工程师：</p>\n<p>职责：\n1、配合产品及设计实现Web平台上的用户功能、移动平台广告样式开发\n2、参与系统的需求分析与设计\n2、持续的优化前端用户体验和页面响应速度，并保证兼容性和执行效率\n3、及时发现和提出问题，并能提出和实践可行性解决方案</p>\n<p>要求：</p>\n<p>1、扎实的 HTML/CSS/JavaScript 基础\n2、有ES6, Webpack实践经验\n3、熟练掌握 React, Angular, Vue 等至少一种框架\n4、有Node.Js实践经验\n5、学习能力强大，喜欢钻研新技术\n6、长期关注和学习新技术，并应用到项目中\n7、良好的沟通能力和团队合作能力\n8、有过Vue或者Angular实践经验优先\n9、有过维护开源项目经验优先</p>\n<p>PHP工程师：\n职责：\n1、负责线上平台WEB应用架构、开发及优化工作\n2、参与系统需求分析与设计\n3、解决业务发展遇到的问题，持续提升系统高可用、稳定\n4、进行 Code Review，提升团队的技术能力和工程能力</p>\n<p>任职资格：</p>\n<p>1、计算机及相关专业本科以上学历；\n2、2年以上PHP项目开发经验\n3、熟悉Linux、PHP、Mysql，具有相关应用开发经验及规划能力\n4、对Laravel框架有深入的理解，了解面向对象编程\n5、熟悉PHP代码优化，熟悉数据库设计与优化，具有MySQL索引优化、查询优化和存储优化经验\n6、长期关注和学习新技术，并应用到项目中\n7、了解Swoole、Node.js等技术优先\n8、具有过Devops实践经验优先\n9、具有过微服务实践经验优先</p>\n<p>福利待遇：</p>\n<p>1、发放父母工资\n2、Mac pro\n3、每年旅游，刚去了巴厘岛</p>\n<p>联系方式：\n<a href=\"mailto:chengnan@wifi.com\">chengnan@wifi.com</a></p>\n</div>",
      "title": "【上海】Wifi万能钥匙 招聘前端工程师【10-20k】",
      "last_reply_at": "2017-05-10T02:44:54.239Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 115,
      "create_at": "2017-05-09T10:49:33.870Z",
      "author": {
        "loginname": "yekexuan",
        "avatar_url": "https://avatars2.githubusercontent.com/u/8479497?v=3&s=120"
      }
    },
    {
      "id": "59125ad3ba8670562a40ee9d",
      "author_id": "5615066cdc59e9c947a53790",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"http://geek.csdn.net/news/detail/195187\">http://geek.csdn.net/news/detail/195187</a></p>\n</div>",
      "title": "转发一篇自己写的JavaScript开发物联网的文章",
      "last_reply_at": "2017-05-10T02:41:25.264Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 140,
      "create_at": "2017-05-10T00:12:03.957Z",
      "author": {
        "loginname": "lizhizhou",
        "avatar_url": "https://avatars.githubusercontent.com/u/1780018?v=3&s=120"
      }
    },
    {
      "id": "591279053504ce1c2ac45a3b",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>转一个 <a href=\"/user/pmq20\">@pmq20</a> 在知乎上的回答</p>\n<p><a href=\"https://www.zhihu.com/question/52670355\">https://www.zhihu.com/question/52670355</a></p>\n<ol>\n<li>\n<p>打包后运行时的路径分为两种：一种是以 /<strong>enclose_io_memfs</strong>/ 开头的，关于这种路径的一切文件系统调用（stat、open、read 等）都会被转发到内存中，而不再发往操作系统；另一种是不以此开头的，这些文件系统调用则保持不变，还是发往操作系统</p>\n</li>\n<li>\n<p>.node 这种二进制模块的行为没有变化，依然从文件系统中加载，因此必须随主程序一起分发</p>\n</li>\n<li>\n<p>js 代码编译的行为也没有变化，还是在运行时由 v8 的设施进行 JIT 编译的，如 Crankshaft 和 Turbofan。该编译器只是将 js 内置到内存之中，随 node 主程序一起链接编译在一起，而没有真正编译 js 代码，参见其底层依赖的项目 <a href=\"http://github.com/pmq20/libsquash\">http://github.com/pmq20/libsquash</a> 。</p>\n</li>\n</ol>\n<p>更多详情请参考： <a href=\"https://speakerdeck.com/pmq20/node-dot-js-compiler-compiling-your-node-dot-js-application-into-a-single-executable\">https://speakerdeck.com/pmq20/node-dot-js-compiler-compiling-your-node-dot-js-application-into-a-single-executable</a></p>\n<p>附与其他类似项目的对比：</p>\n<ul>\n<li>Pkg(<a href=\"https://github.com/zeit/pkg\">https://github.com/zeit/pkg</a>): Pkg 在运行时动态替换了 Node.js 的 fs.* 系列标准库 API 的实现，而 Node.js Compiler 则尽量保持了原有 API 源代码不变，而在更底层的部分用 libsquash 完成工作。Pkg 使用一个大 JSON 来存储内存中的资源文件，而 Node.js Compiler 使用更成熟、更广泛使用的 SquashFS 作为其数据结构。</li>\n<li>EncloseJS(<a href=\"http://enclosejs.com/\">http://enclosejs.com/</a>): EncloseJS 只允许用户使用五个 fs.* API 访问包内文件，而 Node.js Compiler 允许所有的 fs.* API。EncloseJS 使用的是商业许可证，使用时需要付款；而 Node.js Compiler 是 MIT 许可证，使用者可免费试用，更可自由修改其源代码。</li>\n<li>Nexe(<a href=\"https://github.com/nexe/nexe\">https://github.com/nexe/nexe</a>): Nexe 因为使用了 Browserify 的缘故，并不支持动态 require。而 Node.js Compiler 支持所有 require 调用，更支持 require.resolve 调用。</li>\n<li>asar(<a href=\"https://github.com/electron/asar\">https://github.com/electron/asar</a>): Asar 使用 JSON 作为数据结构而 Node.js Compiler 使用 SquashFS。Asar 将代码和可执行文件分离，而 Node.js Compiler 将所有项目代码和 Node.js 本身链接在一起，最终生成一个独立的可执行文件。</li>\n<li>AppImage(<a href=\"http://appimage.org/\">http://appimage.org/</a>): AppImage 只支持 Linux，而且只支持内核开启了 SquashFS 的 Linux。 Node.js Compiler 支持 Windows、macOS、Linux 全部三个平台，且不对 Linux 的内核施加任何特别的功能要求。</li>\n</ul>\n</div>",
      "title": "将node代码打包成一个可执行文件",
      "last_reply_at": "2017-05-10T02:20:53.273Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 91,
      "create_at": "2017-05-10T02:20:53.273Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
      }
    },
    {
      "id": "591275d53504ce1c2ac45a37",
      "author_id": "5807253a487e1e4578afb648",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>SBDoc是一个商业化开源产品，完全免费。无论你是前端工程师，还是后端工程师，接口永远都是两者交互的桥梁，所以SBDoc专为中小型团队量身打造，旨在解决接口的管理，测试与数据生成，实现真正的一体化解决方案。</p>\n<p>1.团队协作，可以对不同的成员分配权限，有两种权限，管理员：可以增删改查项目和接口信息。观察者：可以查看，测试，mock接口数据，但是不能修改接口和项目的信息。</p>\n<p>2.编写接口文档，摒弃了传统的纯文本编写方式，采用可视化编写，随意拖拽，可以添加任意层次信息，支持JSON入参格式，并且实时预览文档编写结果。</p>\n<p>3.对接口进行测试，对于外网测试，没有跨域，后台采用的是proxy代理，对于内网，需要在本地安装node环境，然后下载系统内提示的net.js文档，在本地用node运行即可。net.js就是一个http，https的透明代理。</p>\n<p>4.自动生成接口，很多时候，我们的后端开发人员都是先将接口开发好，再去写接口文档的，或者是接口有比较大的改动，接口文档也要改动很多。对于这种情况，可以在测试接口后对接口的文档信息进行一键自动生成，接口的所有入参，出参，http头都会自动生成到文档，我们要做的就是简单的修修改改就可以啦</p>\n<p>5.可以对接口进行自动化测试，采用原生的js编写少量代码便可以对接口进行高效智能的测试，业内独创web端自动化测试技术！</p>\n<p>6.对数据进行无缝mock，在大部分情况下，前端的开发人员都是要等待后端的开发者将接口开发调试好才能进行下一步开发，这样会耗费大量的时间精力，如果要本地生成数据那么成本也会比较高，所以SBDoc有独特的无缝mock技术。</p>\n<p>2.0.0版本更新内容：</p>\n<p>1.支持项目的导出导入，支持接口，以及分组的导入导出\n2.支持导入postman的v2 json格式文件\n3.在接口编辑页支持入参为json格式的可视化编辑\n4.添加了全局的状态码功能，并且入参和出参可以和状态码进行绑定。\n5.返回参数支持数组格式的可视化编辑\n6.添加了全局注入功能。\n7.在mock中支持<a href=\"/user/code\">@code</a>方法，可以运行自定义的js代码\n8.参数的默认值可以添加备注说明了。\n9.在添加项目成员里新增了导入功能，可以将其他项目的成员导入进来。\n10.接口支持按名称和url关键词来进行搜索了\n11.支持接口的自动化测试了，可以编写测试用例，支持统一运行。\n12.对接口编辑页面进行了UI调整，结构更清晰。</p>\n<p>产品官网：<a href=\"http://sbdoc.cn\">http://sbdoc.cn</a>    <a href=\"http://sbdoc.cn\">http://sbdoc.cn</a>    开源地址： <a href=\"https://github.com/sx1989827/SBDoc\">https://github.com/sx1989827/SBDoc</a></p>\n</div>",
      "title": "接口管理平台SBDoc 2.0 版本发布，添加接口自动化测试",
      "last_reply_at": "2017-05-10T02:07:17.247Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 72,
      "create_at": "2017-05-10T02:07:17.247Z",
      "author": {
        "loginname": "sx1989827",
        "avatar_url": "https://avatars1.githubusercontent.com/u/5820929?v=3&s=120"
      }
    },
    {
      "id": "590d3b633504ce1c2ac45904",
      "author_id": "538ebff9c3ee0b58208376c7",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我想创业。我想问一下，你们公司的老板给员工翻墙（只是在办公场所内翻墙，用于工作）是提供的什么VPN？这需不需要向有关部门登记呀？如果不登记，会不会遭到惩罚？</p>\n</div>",
      "title": "翻墙（办公用途）需要登记吗？",
      "last_reply_at": "2017-05-10T00:44:55.342Z",
      "good": false,
      "top": false,
      "reply_count": 12,
      "visit_count": 593,
      "create_at": "2017-05-06T02:56:35.441Z",
      "author": {
        "loginname": "zhanzhenzhen",
        "avatar_url": "https://avatars0.githubusercontent.com/u/731796?v=3&s=120"
      }
    },
    {
      "id": "5911d49f3504ce1c2ac45a22",
      "author_id": "538ebff9c3ee0b58208376c7",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>有人像我一样想在虚拟机里面玩游戏，但嫌虚拟机不支持DirectX11么？原因是令人崩溃的，刚刚才知道，原来是因为：</p>\n<p>macOS does not support OpenGL Compute Shaders which are required to implement DirectX 11 support</p>\n<p><a href=\"https://forum.parallels.com/threads/parallels-desktop-11-and-directx-11.329342/page-4\">https://forum.parallels.com/threads/parallels-desktop-11-and-directx-11.329342/page-4</a></p>\n</div>",
      "title": "气死人了，macOS里可能永远不能玩Windows游戏了（虚拟机）",
      "last_reply_at": "2017-05-09T16:53:43.336Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 239,
      "create_at": "2017-05-09T14:39:27.198Z",
      "author": {
        "loginname": "zhanzhenzhen",
        "avatar_url": "https://avatars0.githubusercontent.com/u/731796?v=3&s=120"
      }
    },
    {
      "id": "590850d6782dbc4b183ecfb0",
      "author_id": "515005e9604b3d512109bb17",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>先放上 Live 地址：<a href=\"https://www.zhihu.com/lives/842742839304667136\">https://www.zhihu.com/lives/842742839304667136</a></p>\n</blockquote>\n<p>本次 Live 将深入剖析 Node.js 包与模块机制，包括且不限于解析 Node.js 源码、社区规范等。本人认为这是作为一个合格 Node.js 开发者哪怕是不深入也要了解的姿势之一。</p>\n<p>本次 Live 主要包括以下内容：</p>\n<ul>\n<li>CommonJs 模块规范</li>\n<li>CommonJs 包规范</li>\n<li>Node.js 模块规范</li>\n<li>Node.js 包规范</li>\n<li>Node.js 四种模块本质和加载原理</li>\n<li>Node.js 入口模块</li>\n<li>最后带一笔 Node.js 包（如包管理器，通样等）</li>\n</ul>\n<p>当然在 Live 过程中，可能略有出入。</p>\n</div>",
      "title": "开场 Live，分享点干货——「深入了解 Node.js 包与模块机制」",
      "last_reply_at": "2017-05-09T15:28:40.148Z",
      "good": true,
      "top": false,
      "reply_count": 4,
      "visit_count": 581,
      "create_at": "2017-05-02T09:26:46.730Z",
      "author": {
        "loginname": "xadillax",
        "avatar_url": "https://avatars.githubusercontent.com/u/2842176?v=3&s=120"
      }
    },
    {
      "id": "5911881cba8670562a40ee69",
      "author_id": "52cfa5be820152a00e58e1b1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>像这样\n\tres.render(‘user’, { name: ‘Tobi’ }, function(err, html) {\n\t  // …\n\t});</p>\n<p>在网页端 js 中怎么访问到name的值？</p>\n</div>",
      "title": "新手问题，Express发出的内容，网页端 js  怎样取到内容？",
      "last_reply_at": "2017-05-09T14:31:40.821Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 170,
      "create_at": "2017-05-09T09:13:00.189Z",
      "author": {
        "loginname": "yuanjl",
        "avatar_url": "https://avatars3.githubusercontent.com/u/1297308?v=3&s=120"
      }
    }
  ]
}